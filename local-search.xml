<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2021/07/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>​    由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的<strong>中介</strong>。也就是说可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>​    代理模式主要有两种：静态代理和动态代理</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>​    通过增加一个静态代理类，依赖被代理对象，然后在被代理方法的前后添加一些处理逻辑，使在不修改原类的基础上，增加一些功能。满足开闭原则。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</p></li><li><p>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</p></li></ul><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>代理模式的主要角色如下。</p><ol><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ol><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q115093011523.gif" alt="代理模式的结构图"></p><p>图1</p><h3 id="示例代码如下："><a href="#示例代码如下：" class="headerlink" title="示例代码如下："></a>示例代码如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Proxy proxy = <span class="hljs-keyword">new</span> Proxy();<br>        proxy.Request();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象主题</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//真实主题</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问真实主题方法...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (realSubject == <span class="hljs-keyword">null</span>) &#123;<br>            realSubject = <span class="hljs-keyword">new</span> RealSubject();<br>        &#125;<br>        preRequest();<br>        realSubject.Request();<br>        postRequest();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问真实主题之前的预处理。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问真实主题之后的后续处理。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">访问真实主题之前的预处理。<br>访问真实主题方法...<br>访问真实主题之后的后续处理。<br></code></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>​    逻辑跟静态代理是差不多的，我们在使用静态代理的时候，会发现一个弊端：每增加一个代理的需求，都会增加代理类，这样如果要代理的模块很多的话，就会使类的数量增加，增加系统复杂度和代码量。动态代理就是为了动态生成代理类，解决这个痛点。</p><h3 id="静态代理与动态代理的区别主要在："><a href="#静态代理与动态代理的区别主要在：" class="headerlink" title="静态代理与动态代理的区别主要在："></a>静态代理与动态代理的区别主要在：</h3><ul><li>静态代理在<strong>编译</strong>时就已经实现，编译完成后代理类是一个<strong>实际</strong>的class文件</li><li>动态代理是在运行时动态生成的，即编译完成后<strong>没有</strong>实际的class文件，而是在<strong>运行</strong>时动态生成类字节码，并加载到JVM中</li></ul><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-comment">//抽象主题</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//真实主题</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存数据&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//动态代理工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<span class="hljs-comment">// 维护一个目标对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyFactory</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-comment">// 为目标对象生成代理对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                        System.out.println(<span class="hljs-string">&quot;开启事务&quot;</span>);<br><br>                        <span class="hljs-comment">// 执行目标对象方法</span><br>                        Object returnValue = method.invoke(target, args);<br><br>                        System.out.println(<span class="hljs-string">&quot;提交事务&quot;</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestProxy</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDynamicProxy</span> <span class="hljs-params">()</span></span>&#123;<br>        IUserDao target = <span class="hljs-keyword">new</span> UserDao();<br>        System.out.println(target.getClass());  <span class="hljs-comment">//输出目标对象信息</span><br>        IUserDao proxy = (IUserDao) <span class="hljs-keyword">new</span> ProxyFactory(target).getProxyInstance();<br>        System.out.println(proxy.getClass());  <span class="hljs-comment">//输出代理对象信息</span><br>        proxy.save();  <span class="hljs-comment">//执行代理方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">proxy</span>.<span class="hljs-title">UserDao</span></span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">sun</span>.<span class="hljs-title">proxy</span>.$<span class="hljs-title">Proxy4</span></span><br><span class="hljs-class">开启事务</span><br><span class="hljs-class">保存数据</span><br><span class="hljs-class">提交事务</span><br></code></pre></td></tr></table></figure><h3 id="仔细看上面代码你会发现"><a href="#仔细看上面代码你会发现" class="headerlink" title="仔细看上面代码你会发现"></a>仔细看上面代码你会发现</h3><ul><li>ProxyFactory的代码算是实现了<strong>复用</strong>，后面你用了其他抽象主题的代理类，只要(Object) new ProxyFactory(target).getProxyInstance();传入对应的类型，就可以在被代理方法的前后执行ProxyFactory.invoke中的逻辑</li><li>静态代理的代理类在动态代理中就看不见了，被Proxy.newProxyInstance和InvocationHandler.invoke代替了</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>Retrofit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;<br>  Utils.validateServiceInterface(service);<br>  <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>    eagerlyValidateMethods(service);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,<br>      <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Platform platform = Platform.get();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>          <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span><br>          <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (platform.isDefaultMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);<br>          &#125;<br>          <span class="hljs-keyword">return</span> loadServiceMethod(method).invoke(args != <span class="hljs-keyword">null</span> ? args : emptyArgs);<br>        &#125;<br>      &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Android 的跨进程通信</li><li>……</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2021/07/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。（注意Android在多进程下，单例失效，因为不是同一块内存）</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>节约资源，对于需要频繁创建和销毁、占用内存资源比较大的对象能有效节约资源</li><li>避免对资源的多重占用（比如写文件操作）</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>单例类的职责过重，在一定程度上违背了“单一职责原则”</li><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>EventBus、Retrofit、SQLiteOpenHelper、Glide……</p><h4 id="五种使用方式"><a href="#五种使用方式" class="headerlink" title="五种使用方式"></a>五种使用方式</h4><p>1.饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance=<span class="hljs-keyword">new</span> SingletonDemo();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Kotlin实现</span><br>object SingletonDemo<br></code></pre></td></tr></table></figure><ul><li>优点：<ul><li>单例对象的创建是线程安全的；</li><li>获取单例对象时不需要加锁。</li></ul></li><li>缺点：单例对象的创建，不是延时加载。</li></ul><p>2.懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>            instance=<span class="hljs-keyword">new</span> SingletonDemo();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Kotlin实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-title">private</span> <span class="hljs-title">constructor</span>() </span>&#123;<br>    companion object &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: SingletonDemo? = <span class="hljs-function"><span class="hljs-keyword">null</span></span><br><span class="hljs-function">            <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (field == <span class="hljs-keyword">null</span>) &#123;<br>                    field = SingletonDemo()<br>                &#125;<br>                <span class="hljs-keyword">return</span> field<br>            &#125;<br>        <span class="hljs-function">fun <span class="hljs-title">get</span><span class="hljs-params">()</span>: SingletonDemo</span>&#123;<br>        <span class="hljs-comment">//细心的小伙伴肯定发现了，这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字</span><br>         <span class="hljs-keyword">return</span> instance!!<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>3.懒汉线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//使用同步锁</span><br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>            instance=<span class="hljs-keyword">new</span> SingletonDemo();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Kotlin实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-title">private</span> <span class="hljs-title">constructor</span>() </span>&#123;<br>    companion object &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: SingletonDemo? = <span class="hljs-function"><span class="hljs-keyword">null</span></span><br><span class="hljs-function">            <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (field == <span class="hljs-keyword">null</span>) &#123;<br>                    field = SingletonDemo()<br>                &#125;<br>                <span class="hljs-keyword">return</span> field<br>            &#125;<br>        <span class="hljs-meta">@Synchronized</span><br>        <span class="hljs-function">fun <span class="hljs-title">get</span><span class="hljs-params">()</span>: SingletonDemo</span>&#123;<br>            <span class="hljs-keyword">return</span> instance!!<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>优点：<ul><li>对象的创建是线程安全的。</li><li>支持延时加载。</li></ul></li><li>缺点：获取对象的操作被加上了锁，影响了并发度。<ul><li>如果单例对象需要频繁使用，那这个缺点就是无法接受的。</li><li>如果单例对象不需要频繁使用，那这个缺点也无伤大雅。</li></ul></li></ul><p>4.双重校验锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> SingletonDemo instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span></span>&#123;&#125; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance=<span class="hljs-keyword">new</span> SingletonDemo();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//kotlin实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-title">private</span> <span class="hljs-title">constructor</span>() </span>&#123;<br>    companion object &#123;<br>        val instance: <span class="hljs-function">SingletonDemo by <span class="hljs-title">lazy</span><span class="hljs-params">(mode = LazyThreadSafetyMode.SYNCHRONIZED)</span> </span>&#123;<br>        SingletonDemo() &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//或者 来自项目代码中的实现方式</span><br>     companion object &#123;<br><br>                <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> val INTERVAL = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">20.</span>toLong()<br><br>                <span class="hljs-meta">@Volatile</span><br>                <span class="hljs-keyword">var</span> mInstance: AppPrefHelper? = <span class="hljs-function"><span class="hljs-keyword">null</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">                fun <span class="hljs-title">getInstance</span><span class="hljs-params">(context: Context)</span>: AppPrefHelper </span>&#123;<br>                    <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">synchronized</span>(AppPrefHelper::<span class="hljs-class"><span class="hljs-keyword">class</span>) </span>&#123;<br>                            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;<br>                                mInstance = AppPrefHelper(context)<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> mInstance!!<br>                &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><ul><li>对象的创建是线程安全的。</li><li>支持延时加载。</li><li>获取对象时不需要加锁。</li></ul><p>5.静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance=<span class="hljs-keyword">new</span> SingletonDemo();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton has loaded&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//kotlin实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-title">private</span> <span class="hljs-title">constructor</span>() </span>&#123;<br>    companion object &#123;<br>        val instance = SingletonHolder.holder<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> object SingletonHolder &#123;<br>        val holder= SingletonDemo()<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>优点同Double check</p><p>6.枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>  INSTANCE; <span class="hljs-comment">// 该对象全局唯一</span><br>&#125;<br><br><span class="hljs-comment">//kotlin</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">class</span> <span class="hljs-title">Direction</span> </span>&#123;<br>    NORTH, SOUTH, WEST, EAST<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创造型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2021/07/31/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式主要有三种分别是简单工厂模式、工厂方法模式和抽象工厂模式。概念是定义一个创建产品对象的接口，将产品对象的实际创建工作推迟到具体子工厂类当中。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式有一个具体的工厂类，可以生成多个不同的产品（客户端通过配置参数的形式可以生产不同的产品），但是每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，<strong>违背了“开闭原则”</strong>。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>工厂类包含必要的<strong>逻辑判断</strong>，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li><li>客户端无需知道所创建具体产品的类名，<strong>只需知道参数即可</strong>。</li><li>也可以<strong>引入配置文件</strong>，在不修改客户端代码的情况下更换和添加新的具体产品类。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>简单工厂模式的工厂类单一，负责所有产品的创建，<strong>职责过重</strong>，一旦异常，整个系统将受影响。且工厂类代码会非常<strong>臃肿</strong>，违背高聚合原则。</li><li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li><li>系统<strong>扩展困难</strong>，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li><li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>简单工厂模式的主要角色如下：</p><ul><li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li><li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li></ul><p>具体结构图如下：</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/5-200ZQ64244445.png" alt="简单工厂模式的结构图"></p><p>图1</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SimpleFactory.makeProduct(Const.PRODUCT_A);<br>    &#125;<br>    <span class="hljs-comment">//抽象产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>    <span class="hljs-comment">//具体产品：ProductA</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;具体产品1显示...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//具体产品：ProductB</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;具体产品2显示...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Const</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PRODUCT_A = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PRODUCT_B = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PRODUCT_C = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactory</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title">makeProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> kind)</span> </span>&#123;<br>            <span class="hljs-keyword">switch</span> (kind) &#123;<br>                <span class="hljs-keyword">case</span> Const.PRODUCT_A:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct1();<br>                <span class="hljs-keyword">case</span> Const.PRODUCT_B:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct2();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>本质就是对工厂再做一次抽象，使得工厂容易扩展。可以使系统在不修改原来代码的情况下引进新的产品，即<strong>满足开闭原则</strong>。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>用户只需要知道<strong>具体工厂的名称</strong>就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li><li>抽象产品<strong>只能生产一种产品</strong>，此弊端可使用抽象工厂解决。</li></ul><h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p>工厂方法模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><p>具体结构可见下图：</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q114135A2M3.gif" alt="工厂方法模式的结构图"></p><p>图2</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> FactoryMethod;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象产品：提供了产品的接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//具体产品1：实现抽象产品中的抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体产品1显示...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体产品2：实现抽象产品中的抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体产品2显示...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象工厂：提供了厂品的生成方法</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">newProduct</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//具体工厂1：实现了厂品的生成方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">newProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct1();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体工厂2：实现了厂品的生成方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">newProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。简单来说，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>举个例子，农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度</li></ul><h3 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h3><p>抽象工厂模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ol><p>具体结构如下图：</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q11416002NW.gif" alt="抽象工厂模式的结构图"></p><p>图3</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product1 <span class="hljs-title">newProduct1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product2 <span class="hljs-title">newProduct2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product1 <span class="hljs-title">newProduct1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct11();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product2 <span class="hljs-title">newProduct2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct21();<br>    &#125;<br>&#125;<br>……其他部分跟工厂方法类似<br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th>简单工厂</th><th>工厂方法</th><th>抽象工厂</th></tr></thead><tbody><tr><td>使用特点</td><td>传入产品<strong>标识</strong>生产目标产品</td><td>一个工厂对应一个产品</td><td>一个工厂可以生产多类产品，多个工厂对应一类产品</td></tr><tr><td>缺点</td><td>工厂无法扩展</td><td>只能生产一种产品</td><td>扩展复杂度高</td></tr><tr><td>共同点</td><td>对外隐藏创建细节</td><td>对外隐藏创建细节</td><td>对外隐藏创建细节</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>Activity的onCreate()</p><p>对android来说，所有的控件都是继承自View，而基本上View的生成都在onCreate()的当中，所以以工厂模式的角度来看，View就是各类产品，Activity就是一个工厂。</p></li><li><p>……</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创造型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造者模式</title>
    <link href="/2021/07/31/%E6%9E%84%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E6%9E%84%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="构造者模式"><a href="#构造者模式" class="headerlink" title="构造者模式"></a>构造者模式</h1><p>指将一个<strong>复杂</strong>对象的构造与它的<strong>表示</strong>分离，使<strong>同样的构建过程</strong>可以<strong>创建不同的表示</strong>，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>封装性好，构建和表示分离。</li><li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li><li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li></ol><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p><h3 id="传统结构"><a href="#传统结构" class="headerlink" title="传统结构"></a>传统结构</h3><p>建造者（Builder）模式的主要角色如下。</p><ol><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><p>其结构图如图 1 所示。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q1141H441X4.gif" alt="建造者模式的结构图"><br>图1 建造者模式的结构图</p><h4 id="传统使用"><a href="#传统使用" class="headerlink" title="传统使用"></a>传统使用</h4><ul><li>产品角色</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 包含多个组成部件的复杂对象，由具体构造者来创建各个零部件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String partA;<br>    <span class="hljs-keyword">private</span> String partB;<br>    <span class="hljs-keyword">private</span> String partC;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPartA</span><span class="hljs-params">(String partA)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.partA = partA;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPartB</span><span class="hljs-params">(String partB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.partB = partB;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPartC</span><span class="hljs-params">(String partC)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.partC = partC;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 展示产品细节</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>抽象构造者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-comment">//创建产品对象</span><br>    <span class="hljs-keyword">protected</span> Product product = <span class="hljs-keyword">new</span> Product();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.product;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>具体构造者实现类（可以根据不同需求配置不同的构造者，但基本结构一样）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String A;<br>    <span class="hljs-keyword">private</span> String B;<br>    <span class="hljs-keyword">private</span> String C;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteBuilder</span><span class="hljs-params">(String A,String B,String C)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.A = A;<br>        <span class="hljs-keyword">this</span>.B = B;<br>        <span class="hljs-keyword">this</span>.C = C;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartA(A);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartB(B);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartC(C);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>指导类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Builder builder;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder = builder;<br>    &#125;<br>    <span class="hljs-comment">//产品构建与组装方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>        <span class="hljs-keyword">return</span> builder.getProduct();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实际使用方式"><a href="#实际使用方式" class="headerlink" title="实际使用方式"></a>实际使用方式</h3><p>上面展示的传统使用方式虽然是比较科学，是比较符合定义的实现方式，但是使用起来不是很方便。但是我们使用设计模式就是为了让代码使用起来更加的舒服，所以大多数框架使用构造者模式都是将抽象类和指导类省略，直接将具体Builder类作为产品类的静态内部类，这样使用起来就很舒服了。</p><p>具体使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String cpu;<span class="hljs-comment">//必须</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ram;<span class="hljs-comment">//必须</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> usbCount;<span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String keyboard;<span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String display;<span class="hljs-comment">//可选</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Computer</span><span class="hljs-params">(Builder builder)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu=builder.cpu;<br>        <span class="hljs-keyword">this</span>.ram=builder.ram;<br>        <span class="hljs-keyword">this</span>.usbCount=builder.usbCount;<br>        <span class="hljs-keyword">this</span>.keyboard=builder.keyboard;<br>        <span class="hljs-keyword">this</span>.display=builder.display;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String cpu;<span class="hljs-comment">//必须</span><br>        <span class="hljs-keyword">private</span> String ram;<span class="hljs-comment">//必须</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> usbCount;<span class="hljs-comment">//可选</span><br>        <span class="hljs-keyword">private</span> String keyboard;<span class="hljs-comment">//可选</span><br>        <span class="hljs-keyword">private</span> String display;<span class="hljs-comment">//可选</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(String cup,String ram)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.cpu=cup;<br>            <span class="hljs-keyword">this</span>.ram=ram;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setUsbCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> usbCount)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.usbCount = usbCount;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setKeyboard</span><span class="hljs-params">(String keyboard)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.keyboard = keyboard;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setDisplay</span><span class="hljs-params">(String display)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.display = display;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Computer(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//省略getter方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样写的话，在new对象的时候就可以链式调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Computer computer=<span class="hljs-keyword">new</span> Computer.Builder(<span class="hljs-string">&quot;因特尔&quot;</span>,<span class="hljs-string">&quot;三星&quot;</span>)<br>                .setDisplay(<span class="hljs-string">&quot;三星24寸&quot;</span>)<br>                .setKeyboard(<span class="hljs-string">&quot;罗技&quot;</span>)<br>                .setUsbCount(<span class="hljs-number">2</span>)<br>                .build();<br></code></pre></td></tr></table></figure><p>是不是很舒服呢。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>okhttpClient</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient(OkHttpClient.Builder builder) &#123;<br>  ……<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> OkHttpClient <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OkHttpClient(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Retrofit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()<br>    .baseUrl(<span class="hljs-string">&quot;https://api.example.com/&quot;</span>)<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .build();<br></code></pre></td></tr></table></figure><p>待补充……</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创造型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2021/07/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>​    将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>两种，前者类之间的耦合度比后者高（<strong>因为继承</strong>），且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端通过适配器可以<strong>透明</strong>地调用目标接口。</li><li><strong>复用</strong>了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>在很多业务场景中符合开闭原则。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的<strong>复杂性</strong>。</p></li><li><p>增加代码阅读难度，<strong>降低</strong>代码<strong>可读性</strong>，过多使用适配器会使系统代码变得<strong>凌乱</strong>。</p></li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>适配器模式（Adapter）包含以下主要角色。</p><ol><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>​    类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；J<strong>ava 不支持多继承</strong>，但可以定义一个适配器类来<strong>实现当前系统的业务接口</strong>（target），同时<strong>又继承现有组件库中已经存在的组件</strong>（Adaptee）。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q1151045351c.gif" alt="类适配器模式的结构图"></p><p>图1</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> adapter;<br><span class="hljs-comment">//目标接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//适配者接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;       <br>        System.out.println(<span class="hljs-string">&quot;适配者中的业务代码被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//类适配器类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        specificRequest();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdapterTest</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;类适配器模式测试：&quot;</span>);<br>        Target target = <span class="hljs-keyword">new</span> ClassAdapter();<br>        target.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">类适配器模式测试：<br>适配者中的业务代码被调用！<br></code></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>​    对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中（可以通过构造函数引入），该类同时实现当前系统的业务接口。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q1151046105A.gif" alt="对象适配器模式的结构图"></p><p>图2</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> adapter;<br><span class="hljs-comment">//目标接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//适配者接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;       <br>        System.out.println(<span class="hljs-string">&quot;适配者中的业务代码被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对象适配器类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObjectAdapter</span><span class="hljs-params">(Adaptee adaptee)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee=adaptee;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        adaptee.specificRequest();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectAdapterTest</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对象适配器模式测试：&quot;</span>);<br>        Adaptee adaptee = <span class="hljs-keyword">new</span> Adaptee();<br>        Target target = <span class="hljs-keyword">new</span> ObjectAdapter(adaptee);<br>        target.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">对象适配器模式测试：<br>适配者中的业务代码被调用！<br></code></pre></td></tr></table></figure><h3 id="双向适配器模式"><a href="#双向适配器模式" class="headerlink" title="双向适配器模式"></a>双向适配器模式</h3><p>​    双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，主要是通过将适配者和适配器的抽象接口都引入到双向适配器当中，然后待用方法满足目标接口。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q115104Q1604.gif" alt="双向适配器模式的结构图"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> adapter;<br><span class="hljs-comment">//目标接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TwoWayTarget</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//适配者接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TwoWayAdaptee</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//目标实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetRealize</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TwoWayTarget</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;       <br>        System.out.println(<span class="hljs-string">&quot;目标代码被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//适配者实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapteeRealize</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TwoWayAdaptee</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;       <br>        System.out.println(<span class="hljs-string">&quot;适配者代码被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//双向适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoWayAdapter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">TwoWayTarget</span>,<span class="hljs-title">TwoWayAdaptee</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> TwoWayTarget target;<br>    <span class="hljs-keyword">private</span> TwoWayAdaptee adaptee;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoWayAdapter</span><span class="hljs-params">(TwoWayTarget target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>.target=target;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoWayAdapter</span><span class="hljs-params">(TwoWayAdaptee adaptee)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee=adaptee;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        adaptee.specificRequest();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;       <br>        target.request();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoWayAdapterTest</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;目标通过双向适配器访问适配者：&quot;</span>);<br>        TwoWayAdaptee adaptee=<span class="hljs-keyword">new</span> AdapteeRealize();<br>        TwoWayTarget target=<span class="hljs-keyword">new</span> TwoWayAdapter(adaptee);<br>        target.request();<br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;适配者通过双向适配器访问目标：&quot;</span>);<br>        target=<span class="hljs-keyword">new</span> TargetRealize();<br>        adaptee=<span class="hljs-keyword">new</span> TwoWayAdapter(target);<br>        adaptee.specificRequest();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">目标通过双向适配器访问适配者：<br>适配者代码被调用！<br>-------------------<br>适配者通过双向适配器访问目标：<br>目标代码被调用！<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th>类适配器模式</th><th>对象适配器</th><th>双向适配器</th></tr></thead><tbody><tr><td></td><td>继承</td><td>依赖注入</td><td>依赖注入</td></tr></tbody></table><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2021/07/31/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型的是一种创建型的设计模式，<strong>主要用来创建的复杂的对象和构建耗时的实例</strong>。通过克隆已有的对象来创建的新的对象，从而节省时间和内存。通过克隆一个已经存在的实例可以使我们的程序运行的更高效。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>对于创建需要消耗大量资源的大对象，使用该模式性能有显著提高</li><li>可以逃避构造函数的约束</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>对于不支持串行化的对象，或者存在循环结构的时候，配置很困难</li><li>必须实现Cloneable接口，才能调用clone()方法，否则报错CloneNotSupportedException</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>ArrayList类中的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();<br>        v.elementData = Arrays.copyOf(elementData, size);<br>        v.modCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-comment">// this shouldn&#x27;t happen, since we are Cloneable</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Bundle类中的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bundle(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bundle</span><span class="hljs-params">(Bundle b)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(b);<br>    mFlags = b.mFlags;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Intent类中的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Intent</span><span class="hljs-params">(Intent o)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.mAction = o.mAction;<br>    <span class="hljs-keyword">this</span>.mData = o.mData;<br>    <span class="hljs-keyword">this</span>.mType = o.mType;<br>    <span class="hljs-keyword">this</span>.mPackage = o.mPackage;<br>    <span class="hljs-keyword">this</span>.mComponent = o.mComponent;<br>    <span class="hljs-keyword">this</span>.mFlags = o.mFlags;<br>    <span class="hljs-keyword">this</span>.mContentUserHint = o.mContentUserHint;<br>    <span class="hljs-keyword">if</span> (o.mCategories != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.mCategories = <span class="hljs-keyword">new</span> ArraySet&lt;String&gt;(o.mCategories);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (o.mExtras != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.mExtras = <span class="hljs-keyword">new</span> Bundle(o.mExtras);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (o.mSourceBounds != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.mSourceBounds = <span class="hljs-keyword">new</span> Rect(o.mSourceBounds);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (o.mSelector != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.mSelector = <span class="hljs-keyword">new</span> Intent(o.mSelector);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (o.mClipData != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.mClipData = <span class="hljs-keyword">new</span> ClipData(o.mClipData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>原型模式主要有三类对象，第一个是实现了 <em>Cloneable</em> 接口的抽象类，第二个是实现抽象类的具体原型对象，第三个是调用方。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/image-20210719175154771.png" alt="image-20210719175154771"></p><ul><li>实现Cloneable的抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>   <br>   <span class="hljs-keyword">private</span> String id;<br>   <span class="hljs-keyword">protected</span> String type;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> type;<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> id;<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.id = id;<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>      Object clone = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>         clone = <span class="hljs-keyword">super</span>.clone();<br>      &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>         e.printStackTrace();<br>      &#125;<br>      <span class="hljs-keyword">return</span> clone;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现抽象类的具体原型对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Rectangle.java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">()</span></span>&#123;<br>     type = <span class="hljs-string">&quot;Rectangle&quot;</span>;<br>   &#125;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Inside Rectangle::draw() method.&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Square.java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">()</span></span>&#123;<br>     type = <span class="hljs-string">&quot;Square&quot;</span>;<br>   &#125;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Inside Square::draw() method.&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Circle.java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span>&#123;<br>     type = <span class="hljs-string">&quot;Circle&quot;</span>;<br>   &#125;<br> <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Inside Circle::draw() method.&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Shape clonedShape = (Shape) ShapeCache.getShape(<span class="hljs-string">&quot;1&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Shape : &quot;</span> + clonedShape.getType());        <br> <br>Shape clonedShape2 = (Shape) ShapeCache.getShape(<span class="hljs-string">&quot;2&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Shape : &quot;</span> + clonedShape2.getType());        <br> <br>Shape clonedShape3 = (Shape) ShapeCache.getShape(<span class="hljs-string">&quot;3&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Shape : &quot;</span> + clonedShape3.getType()); <br></code></pre></td></tr></table></figure><h4 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h4><p>仔细观察抽象类的话，大家会发现它只是简单地用对象调用了cloneable接口的方法而已，并没有对内部的属性处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">clone = <span class="hljs-keyword">super</span>.clone();<br></code></pre></td></tr></table></figure><p>他其实是一种浅拷贝的方式，这里大家需要区分浅拷贝和深拷贝的区别。</p><blockquote><p>浅拷贝：基本数据类型赋相同值，而引用类型只是传递引用地址，也就是说，修改浅拷贝中的引用对象的内容，原本的对象对应的对象内容也会改变</p><p>深拷贝：相当于new了一份新的，是不同的对象，但是具有相同的内容</p></blockquote><p>如果要使用clone()方法实现深拷贝，则需要将对象里面的引用对象也全部都调用clone()方法，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> WordDocument implements Cloneable&#123;<br>    String mText;<br>    ArrayList&lt;String&gt; mImages;<br>    ......<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WordDocument <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            WordDocument doc = (WordDocument) <span class="hljs-keyword">super</span>.clone();<br>            doc.mText = <span class="hljs-keyword">this</span>.mText;<br>            doc.mImages = (ArrayList&lt;String&gt;) <span class="hljs-keyword">this</span>.mImages.clone();<span class="hljs-comment">//类里面的引用类型对象也要调用clone()</span><br>            <span class="hljs-keyword">return</span> doc;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="登记型原型模式"><a href="#登记型原型模式" class="headerlink" title="登记型原型模式"></a>登记型原型模式</h4><p>其实就是在调用方多增加一个Manager管理类，该类中维护一个HashMap&lt;ID,Obj&gt;，他的key的表示的是对象的标识，value表示的是对象的实例，这样做的好处就是可以利用HashMap查询时间复杂度O（1）的特点，同时又可以将这些大对象缓存起来，这样在一定程度上能对多个大对象提高创建效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeManager</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来记录原型的编号和原型实例的对应关系</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Prototype&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,Prototype&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有化构造方法，避免外部创建实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PrototypeManager</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向原型管理器里面添加或是修改某个原型注册</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prototypeId 原型编号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prototype    原型实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrototype</span><span class="hljs-params">(String prototypeId , Prototype prototype)</span></span>&#123;<br>        map.put(prototypeId, prototype);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从原型管理器里面删除某个原型注册</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prototypeId 原型编号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removePrototype</span><span class="hljs-params">(String prototypeId)</span></span>&#123;<br>        map.remove(prototypeId);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取某个原型编号对应的原型实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prototypeId    原型编号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>    原型编号对应的原型实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception    如果原型编号对应的实例不存在，则抛出异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Prototype <span class="hljs-title">getPrototype</span><span class="hljs-params">(String prototypeId)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Prototype prototype = map.get(prototypeId);<br>        <span class="hljs-keyword">if</span>(prototype == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;您希望获取的原型还没有注册或已被销毁&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> prototype;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创造型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合模式</title>
    <link href="/2021/07/31/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>​    组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象<strong>具有一致的访问性</strong>，属于结构型设计模式。</p><p>​    组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/5-201019124253553.png" alt="组合模式树形结构图"></p><p>​    由上图可以看出，其实根节点和树枝节点本质上<strong>属于同一种数据类型</strong>，可以作为<strong>容器</strong>使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（<strong>用统一接口定义</strong>），让它们<strong>具备一致行为</strong>。</p><p>这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来<strong>极大的便利</strong>。</p><p>举个例子：文件夹结构，我们在点击文件夹的时候，文件夹只是起到一个容器的作用，用来管理文件，而文件夹可以跟文件共处在同一层，说明文件夹和文件的结构是一样的，而当我们打开文件的时候，才是真正的使用到文件的功能。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/image-20210727204840351.png" alt="image-20210727204840351"></p><p>图2</p><p>这就是组合模式的设计动机：组合模式定义了如何将容器对象和叶子对象进行<strong>递归组合</strong>，使得客户在使用的过程中无须进行区分，可以对他们进行<strong>一致的处理</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能；</li></ol><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>组合模式包含以下主要角色。</p><ol><li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）</li><li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。</li><li>树枝构件（Composite）角色 / 中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li></ol><p>主要有两种实现方式：</p><ul><li><p>透明方式</p><p>在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端<strong>无须区别</strong>树叶对象和树枝对象，对客户端来说是<strong>透明</strong>的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（<strong>空实现或抛异常</strong>），这样会带来一些安全性问题。</p></li></ul><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q1151G62L17.gif" alt="透明式的组合模式的结构图"></p><p>图3</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositePattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Component c0 = <span class="hljs-keyword">new</span> Composite();<br>        Component c1 = <span class="hljs-keyword">new</span> Composite();<br>        Component leaf1 = <span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;1&quot;</span>);<br>        Component leaf2 = <span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;2&quot;</span>);<br>        Component leaf3 = <span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;3&quot;</span>);<br>        c0.add(leaf1);<br>        c0.add(c1);<br>        c1.add(leaf2);<br>        c1.add(leaf3);<br>        c0.operation();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象构件</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//树叶构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Leaf</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;树叶&quot;</span> + name + <span class="hljs-string">&quot;：被访问！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//树枝构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;Component&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        children.add(c);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        children.remove(c);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> children.get(i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Object obj : children) &#123;<br>            ((Component) obj).operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">树叶1：被访问！<br>树叶2：被访问！<br>树叶3：被访问！<br></code></pre></td></tr></table></figure><ul><li><p>安全模式</p><p>在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</p></li></ul><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q1151GF5221.gif" alt="安全式的组合模式的结构图"></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositePattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Composite c0 = <span class="hljs-keyword">new</span> Composite();<br>        Composite c1 = <span class="hljs-keyword">new</span> Composite();<br>        Component leaf1 = <span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;1&quot;</span>);<br>        Component leaf2 = <span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;2&quot;</span>);<br>        Component leaf3 = <span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;3&quot;</span>);<br>        c0.add(leaf1);<br>        c0.add(c1);<br>        c1.add(leaf2);<br>        c1.add(leaf3);<br>        c0.operation();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象构件</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//树叶构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Leaf</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;树叶&quot;</span> + name + <span class="hljs-string">&quot;：被访问！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//树枝构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;Component&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        children.add(c);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        children.remove(c);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> children.get(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Object obj : children) &#123;<br>            ((Component) obj).operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出同上</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>比较项</th><th>透明</th><th>安全</th></tr></thead><tbody><tr><td>方便性</td><td>树叶和树枝都一视同仁，通过接口统一调用</td><td>需要调用者有主观区分树叶和树枝</td></tr><tr><td>安全性</td><td>空方法存在安全隐患</td><td>比较安全</td></tr><tr><td>原则</td><td>违反<strong>单一职责原则</strong>和<strong>接口隔离原则</strong>来换取透明性，但遵循<strong>依赖倒置</strong>原则</td><td>违反了<strong>依赖倒置原则</strong>，但遵循了<strong>单一职责原则</strong>与<strong>接口隔离原则</strong>。</td></tr></tbody></table><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>Android的View树</p></li><li><p>……</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2021/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>创建型模式（5种）：</p><p>  工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式（7种）：</p><p>  适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式（11种）：</p><p>  策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><table><thead><tr><th align="center">首字母</th><th align="center">指代</th><th align="center">概念</th></tr></thead><tbody><tr><td align="center">S</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">单一功能原则</a></td><td align="center">认为“<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">对象</a>应该仅具有一种单一功能”的概念。</td></tr><tr><td align="center">O</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a></td><td align="center">认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td></tr><tr><td align="center">L</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a></td><td align="center">认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考<a href="https://zh.wikipedia.org/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1">契约式设计</a>。</td></tr><tr><td align="center">I</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则</a></td><td align="center">要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</td></tr><tr><td align="center">l</td><td align="center">迪米特原则</td><td align="center">如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</td></tr><tr><td align="center">D</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">依赖反转原则</a></td><td align="center">高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</td></tr></tbody></table><p>接下来抽空做些总结～</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2021/07/31/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/31/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>​    面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。<strong>当对象数量太多时，将导致运行代价过高，带来性能下降等问题。</strong>享元模式通过共享技术实现相同或相似对象的重用提高系统资源的利用率。    </p><p>​    运用共享技术来有效地支持<strong>大量细粒度对象的复用</strong>。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量<strong>相似类</strong>的开销，从而提高系统资源的利用率。</p><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用享元模式：</p><ul><li>一个系统有大量<strong>相同或者相似</strong>的对象，由于这类对象的大量使用，造成内存的<strong>大量耗费</strong>；</li><li>对象的大部分状态都可以<strong>外部化</strong>，可以将这些外部状态传入细粒度对象中；</li><li>使用享元模式需要维护一个存储享元对象的<strong>享元池</strong>，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；</p></li><li><p>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的<strong>逻辑复杂化</strong>；</p></li><li><p>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得<strong>运行时间变长</strong></p></li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>享元模式的主要角色有如下。</p><ol><li>抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li><li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li><li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式<strong>注入</strong>具体享元的相关方法中。</li><li>享元工厂（Flyweight Factory）角色：<strong>负责创建和管理享元角色</strong>。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。（<strong>含有对象池</strong>）</li></ol><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q115161342242.gif" alt="享元模式的结构图"></p><p>图1</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightPattern</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FlyweightFactory factory = <span class="hljs-keyword">new</span> FlyweightFactory();<br>        Flyweight f01 = factory.getFlyweight(<span class="hljs-string">&quot;a&quot;</span>);<br>        Flyweight f02 = factory.getFlyweight(<span class="hljs-string">&quot;a&quot;</span>);<br>        Flyweight f03 = factory.getFlyweight(<span class="hljs-string">&quot;a&quot;</span>);<br>        Flyweight f11 = factory.getFlyweight(<span class="hljs-string">&quot;b&quot;</span>);<br>        Flyweight f12 = factory.getFlyweight(<span class="hljs-string">&quot;b&quot;</span>);<br>        f01.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第1次调用a。&quot;</span>));<br>        f02.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第2次调用a。&quot;</span>));<br>        f03.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第3次调用a。&quot;</span>));<br>        f11.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第1次调用b。&quot;</span>));<br>        f12.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第2次调用b。&quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//非享元角色</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String info;<br><br>    UnsharedConcreteFlyweight(String info) &#123;<br>        <span class="hljs-keyword">this</span>.info = info;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> info;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(String info)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.info = info;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象享元角色</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(UnsharedConcreteFlyweight state)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//具体享元角色</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String key;<br><br>    ConcreteFlyweight(String key) &#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        System.out.println(<span class="hljs-string">&quot;具体享元&quot;</span> + key + <span class="hljs-string">&quot;被创建！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(UnsharedConcreteFlyweight outState)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;具体享元&quot;</span> + key + <span class="hljs-string">&quot;被调用，&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;非享元信息是:&quot;</span> + outState.getInfo());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//享元工厂角色</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="hljs-keyword">new</span> HashMap&lt;String, Flyweight&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">getFlyweight</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        Flyweight flyweight = (Flyweight) flyweights.get(key);<br>        <span class="hljs-keyword">if</span> (flyweight != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;具体享元&quot;</span> + key + <span class="hljs-string">&quot;已经存在，被成功获取！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            flyweight = <span class="hljs-keyword">new</span> ConcreteFlyweight(key);<br>            flyweights.put(key, flyweight);<br>        &#125;<br>        <span class="hljs-keyword">return</span> flyweight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">具体享元a被创建！<br>具体享元a已经存在，被成功获取！<br>具体享元a已经存在，被成功获取！<br>具体享元b被创建！<br>具体享元b已经存在，被成功获取！<br>具体享元a被调用，非享元信息是:第<span class="hljs-number">1</span>次调用a。<br>具体享元a被调用，非享元信息是:第<span class="hljs-number">2</span>次调用a。<br>具体享元a被调用，非享元信息是:第<span class="hljs-number">3</span>次调用a。<br>具体享元b被调用，非享元信息是:第<span class="hljs-number">1</span>次调用b。<br>具体享元b被调用，非享元信息是:第<span class="hljs-number">2</span>次调用b。<br></code></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>上面例子展示的是传统的享元模式，细粒度的共享对象+外部注入的非共享对象，实际也可以扩展成<strong>单纯享元模式</strong>和<strong>复合享元模式</strong></p><h3 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h3><p>​    这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q115161549429.gif" alt="单纯享元模式的结构图"></p><p>图2</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//抽象享元角色类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-comment">//一个示意性方法，参数state是外蕴状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String state)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//具体享元角色类</span><br><span class="hljs-comment">//具体享元角色类ConcreteFlyweight有一个内蕴状态，在本例中一个Character类型的intrinsicState属性代表，它的值应当在享元对象</span><br><span class="hljs-comment">//被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。如果一个享元对象有外蕴状态的话，所有的外部状态都必须存储在客户端，</span><br><span class="hljs-comment">//在使用享元对象时，再由客户端传入享元对象。这里只有一个外蕴状态，operation()方法的参数state就是由外部传入的外蕴状态。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Character intrinsicState = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，内蕴状态作为参数传入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> state</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFlyweight</span><span class="hljs-params">(Character state)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.intrinsicState = state;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 外蕴状态作为参数传入方法中，改变方法的行为，</span><br><span class="hljs-comment">     * 但是并不改变对象的内蕴状态。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;Intrinsic State = &quot;</span> + <span class="hljs-keyword">this</span>.intrinsicState);<br>        System.out.println(<span class="hljs-string">&quot;Extrinsic State = &quot;</span> + state);<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-comment">//享元工厂角色类</span><br><span class="hljs-comment">//享元工厂角色类，必须指出的是，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。</span><br><span class="hljs-comment">//一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。</span><br><br><span class="hljs-comment">//当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的</span><br><span class="hljs-comment">//享元对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Character,Flyweight&gt; files = <span class="hljs-keyword">new</span> HashMap&lt;Character,Flyweight&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">factory</span><span class="hljs-params">(Character state)</span></span>&#123;<br>        <span class="hljs-comment">//先从缓存中查找对象</span><br>        Flyweight fly = files.get(state);<br>        <span class="hljs-keyword">if</span>(fly == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//如果对象不存在则创建一个新的Flyweight对象</span><br>            fly = <span class="hljs-keyword">new</span> ConcreteFlyweight(state);<br>            <span class="hljs-comment">//把这个新的Flyweight对象添加到缓存中</span><br>            files.put(state, fly);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fly;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//客户端类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        FlyweightFactory factory = <span class="hljs-keyword">new</span> FlyweightFactory();<br>        Flyweight fly = factory.factory(<span class="hljs-keyword">new</span> Character(<span class="hljs-string">&#x27;a&#x27;</span>));<br>        fly.operation(<span class="hljs-string">&quot;First Call&quot;</span>);<br><br>        fly = factory.factory(<span class="hljs-keyword">new</span> Character(<span class="hljs-string">&#x27;b&#x27;</span>));<br>        fly.operation(<span class="hljs-string">&quot;Second Call&quot;</span>);<br><br>        fly = factory.factory(<span class="hljs-keyword">new</span> Character(<span class="hljs-string">&#x27;a&#x27;</span>));<br>        fly.operation(<span class="hljs-string">&quot;Third Call&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h3><p>​    将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p><p><img src="https://gitee.com/zhang_xiao_tou/zhangxiaotou_picture/raw/master/images/3-1Q11516162C42.gif" alt="复合享元模式的结构图"></p><p>图3</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//抽象享元角色类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-comment">//一个示意性方法，参数state是外蕴状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String state)</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">//具体享元角色类</span><br><span class="hljs-comment">//具体享元角色类ConcreteFlyweight有一个内蕴状态，在本例中一个Character类型的intrinsicState属性代表，它的值应当在享元对象</span><br><span class="hljs-comment">//被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。如果一个享元对象有外蕴状态的话，所有的外部状态都必须存储在客户端，</span><br><span class="hljs-comment">//在使用享元对象时，再由客户端传入享元对象。这里只有一个外蕴状态，operation()方法的参数state就是由外部传入的外蕴状态。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Character intrinsicState = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，内蕴状态作为参数传入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> state</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFlyweight</span><span class="hljs-params">(Character state)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.intrinsicState = state;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 外蕴状态作为参数传入方法中，改变方法的行为，</span><br><span class="hljs-comment">     * 但是并不改变对象的内蕴状态。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;Intrinsic State = &quot;</span> + <span class="hljs-keyword">this</span>.intrinsicState);<br>        System.out.println(<span class="hljs-string">&quot;Extrinsic State = &quot;</span> + state);<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-comment">//复合享元角色类</span><br><span class="hljs-comment">//复合享元对象是由单纯享元对象通过复合而成的，因此它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，</span><br><span class="hljs-comment">//这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。</span><br><span class="hljs-comment">//复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。</span><br><span class="hljs-comment">//一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；</span><br><span class="hljs-comment">//而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCompositeFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Character,Flyweight&gt; files = <span class="hljs-keyword">new</span> HashMap&lt;Character,Flyweight&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 增加一个新的单纯享元对象到聚集中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Character key , Flyweight fly)</span></span>&#123;<br>        files.put(key,fly);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 外蕴状态作为参数传入到方法中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        Flyweight fly = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span>(Object o : files.keySet())&#123;<br>            fly = files.get(o);<br>            fly.operation(state);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-comment">//享元工厂角色类</span><br><span class="hljs-comment">//享元工厂角色提供两种不同的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Character,Flyweight&gt; files = <span class="hljs-keyword">new</span> HashMap&lt;Character,Flyweight&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 复合享元工厂方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">factory</span><span class="hljs-params">(List&lt;Character&gt; compositeState)</span></span>&#123;<br>        ConcreteCompositeFlyweight compositeFly = <span class="hljs-keyword">new</span> ConcreteCompositeFlyweight();<br><br>        <span class="hljs-keyword">for</span>(Character state : compositeState)&#123;<br>            compositeFly.add(state,<span class="hljs-keyword">this</span>.factory(state));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> compositeFly;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单纯享元工厂方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">factory</span><span class="hljs-params">(Character state)</span></span>&#123;<br>        <span class="hljs-comment">//先从缓存中查找对象</span><br>        Flyweight fly = files.get(state);<br>        <span class="hljs-keyword">if</span>(fly == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//如果对象不存在则创建一个新的Flyweight对象</span><br>            fly = <span class="hljs-keyword">new</span> ConcreteFlyweight(state);<br>            <span class="hljs-comment">//把这个新的Flyweight对象添加到缓存中</span><br>            files.put(state, fly);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fly;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//客户端类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Character&gt; compositeState = <span class="hljs-keyword">new</span> ArrayList&lt;Character&gt;();<br>        compositeState.add(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        compositeState.add(<span class="hljs-string">&#x27;b&#x27;</span>);<br>        compositeState.add(<span class="hljs-string">&#x27;c&#x27;</span>);<br>        compositeState.add(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        compositeState.add(<span class="hljs-string">&#x27;b&#x27;</span>);<br><br>        FlyweightFactory flyFactory = <span class="hljs-keyword">new</span> FlyweightFactory();<br>        Flyweight compositeFly1 = flyFactory.factory(compositeState);<br>        Flyweight compositeFly2 = flyFactory.factory(compositeState);<br>        compositeFly1.operation(<span class="hljs-string">&quot;Composite Call&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);        <br>        System.out.println(<span class="hljs-string">&quot;复合享元模式是否可以共享对象：&quot;</span> + (compositeFly1 == compositeFly2));<br><br>        Character state = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        Flyweight fly1 = flyFactory.factory(state);<br>        Flyweight fly2 = flyFactory.factory(state);<br>        System.out.println(<span class="hljs-string">&quot;单纯享元模式是否可以共享对象：&quot;</span> + (fly1 == fly2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>String池</li><li>Message池</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
